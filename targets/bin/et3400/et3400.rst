                              1 ;****************************************************************
                              2 ; This file is auto-generated by ddmake from et3400.toml
                              3 ; *** DO NOT EDIT ***
                              4 ;****************************************************************
                              5 
                              6 ; Start of chip memory mapping
                     F800     7 STRTADD = 0xf800
                              8 
                              9 ; 2K ROM
                     0800    10 ROMSIZE = 0x0800
                             11 
                             12 ; Start of ram, needs 7 bytes starting here
                             13 ; On the 6502, you can usually you can count on there being RAM in page 0
                     0000    14 RAMSTRT = 0x0000
                             15 
                             16 ; Start of stack, needs some memory below this address
                     00FF    17 SSTACK = 0x00ff
                             18 
                             19 ; delay factor
                     0180    20 BIGDEL = 0x0180
                             21 
                             22         .include "../core/dd.def"
                              1 
                     0000     2 ROMEND  .equ    STRTADD+ROMSIZE
                              3 
                              4 
                             23         .include "../core/6800.def"
                              1 ; Same for all 6800s
                     FFF8     2 VECTORS .equ    0xfff8      ; location of Vector table
                             24         .include "../io/romio.def"
                              1 ; For Demon Debugger Hardware - Rev D 
                              2 
                     FFA0     3 IOREGR   .equ   STRTADD+0x07a0    ;reserved region for IO READ
                     FFC0     4 IOREGW   .equ   STRTADD+0x07c0    ;reserved region for IO WRITE
                              5 
                     FFA0     6 IOADD    .equ   IOREGR            ;start of region
                     FFE0     7 IOEND    .equ   STRTADD+0x07e0    ;end of region
                             25 
                             26 ;------- region1  -----------------------------------------------
                             27 
                             28         .bank   region1 (base=STRTADD, size=IOADD-STRTADD)
                             29         .area   region1 (ABS, BANK=region1)
                             30 
                             31 ;
                             32 ;       START CODE
                             33 ;
   F800                      34 START:
   F800 0F            [ 2]   35         sei              ; Disable interrupts - we don't handle them
   F801 8E 00 FF      [ 3]   36         lds     #SSTACK  ; set up the stack
                             37 ;       YOUR CODE CAN GO HERE
   F804 7E F8 07      [ 3]   38         jmp     INIT
                             39 
                             40         .include "../core/6800_main.asm"
                              1 
                              2 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              3 ; RAM Variables 
                              4 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              5 
                     0000     6 OUTBUF  .equ    RAMSTRT         ;buffer for output states
                     0001     7 BREG    .equ    RAMSTRT+0x01    ;general purpose
                     0002     8 C       .equ    RAMSTRT+0x02    ;general purpose
                     0003     9 CMDBUF0 .equ    RAMSTRT+0x03    ;command buffer
                     0004    10 CMDBUF1 .equ    RAMSTRT+0x04    ;command buffer
                     0005    11 CMDBUF2 .equ    RAMSTRT+0x05    ;command buffer
                     0006    12 CMDBUF3 .equ    RAMSTRT+0x06    ;command buffer
                             13 
                             14 ; I2C ADDRESSING
                     0011    15 I2CRADR .equ    0x11        ; I2C read address  - I2C address 0x08
                     0010    16 I2CWADR .equ    0x10        ; I2C write address - I2C address 0x08
                             17 
   F807                      18 INIT:
   F807 86 00         [ 2]   19         ldaa    #0x00
   F809 97 00         [ 4]   20         staa    OUTBUF
                             21 
                             22 ; Main routine
   F80B                      23 MAIN:
   F80B BD F9 09      [ 9]   24         jsr     EVERY
   F80E BD F8 C3      [ 9]   25         jsr     POLL
   F811 25 F8         [ 4]   26         bcs     MAIN
   F813 86 01         [ 2]   27         ldaa    #BIGDEL>>8
   F815 97 01         [ 4]   28         staa    BREG
   F817 86 80         [ 2]   29         ldaa    #BIGDEL%256
   F819 97 02         [ 4]   30         staa    C
   F81B                      31 MLOOP:
   F81B 96 02         [ 3]   32         ldaa    C
   F81D 27 06         [ 4]   33         beq     DECBOTH
   F81F 7A 00 02      [ 6]   34         dec     C
   F822 7E F8 1B      [ 3]   35         jmp     MLOOP
   F825                      36 DECBOTH:
   F825 96 01         [ 3]   37         ldaa    BREG
   F827 27 E2         [ 4]   38         beq     MAIN
   F829 7A 00 02      [ 6]   39         dec     C
   F82C 7A 00 01      [ 6]   40         dec     BREG
   F82F 7E F8 1B      [ 3]   41         jmp     MLOOP
                             42 
                             43 ; Delay for half a bit time
   F832 39            [ 5]   44 I2CDLY: rts             ; TBD - this is plenty?
                             45 
                             46 ; I2C Start Condition
   F833                      47 I2CSTART:
   F833 BD F9 49      [ 9]   48         jsr    CLRSDA      
   F836 BD F9 20      [ 9]   49         jsr    CLRSCL
   F839 39            [ 5]   50         rts
                             51 
                             52 ; I2C Stop Condition
                             53 ; Uses HL
                             54 ; Destroys A
   F83A                      55 I2CSTOP:
   F83A BD F9 49      [ 9]   56         jsr    CLRSDA
   F83D BD F9 0A      [ 9]   57         jsr    SETSCL
   F840 BD F9 33      [ 9]   58         jsr    SETSDA
   F843 39            [ 5]   59         rts
                             60         
   F844                      61 I2CRBIT:
   F844 BD F9 33      [ 9]   62         jsr     SETSDA
   F847 BD F9 0A      [ 9]   63         jsr     SETSCL
   F84A BD F9 5F      [ 9]   64         jsr     READSDA ; sets/clears carry flag
   F84D 49            [ 2]   65         rola            ; save carry flag here
   F84E 36            [ 4]   66         psha
   F84F BD F9 20      [ 9]   67         jsr     CLRSCL
   F852 32            [ 4]   68         pula
   F853 46            [ 2]   69         rora            ; restore carry flag here
   F854 39            [ 5]   70         rts             ; carry flag still good here
                             71 
   F855                      72 I2CWBIT:
   F855 24 06         [ 4]   73         bcc     DOCLR
   F857 BD F9 33      [ 9]   74         jsr     SETSDA
   F85A 7E F8 60      [ 3]   75         jmp     AHEAD
   F85D                      76 DOCLR:
   F85D BD F9 49      [ 9]   77         jsr     CLRSDA
   F860                      78 AHEAD:
   F860 BD F9 0A      [ 9]   79         jsr     SETSCL
   F863 BD F9 20      [ 9]   80         jsr     CLRSCL
   F866 39            [ 5]   81         rts
                             82         
   F867                      83 I2CWBYTE:
   F867 C6 08         [ 2]   84         ldab    #0x08   
   F869                      85 ILOOP:
   F869 49            [ 2]   86         rola                ; high bit into carry
   F86A 36            [ 4]   87         psha
   F86B BD F8 55      [ 9]   88         jsr     I2CWBIT
   F86E 32            [ 4]   89         pula
   F86F 5A            [ 2]   90         decb
   F870 26 F7         [ 4]   91         bne     ILOOP
   F872 BD F8 44      [ 9]   92         jsr     I2CRBIT
   F875 39            [ 5]   93         rts
                             94         
   F876                      95 I2CRBYTE:
   F876 C6 08         [ 2]   96         ldab    #0x08
   F878 86 00         [ 2]   97         ldaa    #0x00
   F87A                      98 LOOP3:
   F87A 36            [ 4]   99         psha
   F87B BD F8 44      [ 9]  100         jsr     I2CRBIT     ; get bit in carry flag
   F87E 32            [ 4]  101         pula
   F87F 49            [ 2]  102         rola                ; rotate carry into bit0
   F880 5A            [ 2]  103         decb
   F881 26 F7         [ 4]  104         bne     LOOP3
   F883 0C            [ 2]  105         clc                 ; clear carry flag 
   F884 36            [ 4]  106         psha             
   F885 BD F8 55      [ 9]  107         jsr     I2CWBIT
   F888 32            [ 4]  108         pula
   F889 39            [ 5]  109         rts
                            110 
   F88A                     111 I2CRREQ:
   F88A BD F8 33      [ 9]  112         jsr     I2CSTART
   F88D 86 11         [ 2]  113         ldaa    #I2CRADR
   F88F BD F8 67      [ 9]  114         jsr     I2CWBYTE
   F892 25 17         [ 4]  115         bcs     SKIP
   F894 BD F8 76      [ 9]  116         jsr     I2CRBYTE
   F897 97 03         [ 4]  117         staa    CMDBUF0
   F899 BD F8 76      [ 9]  118         jsr     I2CRBYTE
   F89C 97 04         [ 4]  119         staa    CMDBUF1
   F89E BD F8 76      [ 9]  120         jsr     I2CRBYTE
   F8A1 97 05         [ 4]  121         staa    CMDBUF2
   F8A3 BD F8 76      [ 9]  122         jsr     I2CRBYTE
   F8A6 97 06         [ 4]  123         staa    CMDBUF3
   F8A8 7E F8 BF      [ 3]  124         jmp     ENDI2C
                            125     
   F8AB                     126 SKIP:                       ; If no device present, fake an idle response
   F8AB 86 2E         [ 2]  127         ldaa    #0x2e  ; '.'
   F8AD 97 03         [ 4]  128         staa    CMDBUF0
   F8AF 7E F8 BF      [ 3]  129         jmp     ENDI2C
                            130 
   F8B2                     131 I2CSRESP:
   F8B2 36            [ 4]  132         psha
   F8B3 BD F8 33      [ 9]  133         jsr     I2CSTART
   F8B6 86 10         [ 2]  134         ldaa    #I2CWADR
   F8B8 BD F8 67      [ 9]  135         jsr     I2CWBYTE
   F8BB 32            [ 4]  136         pula
   F8BC BD F8 67      [ 9]  137         jsr     I2CWBYTE
   F8BF                     138 ENDI2C:
   F8BF BD F8 3A      [ 9]  139         jsr     I2CSTOP
   F8C2 39            [ 5]  140         rts
                            141 
   F8C3                     142 POLL:
   F8C3 BD F8 8A      [ 9]  143         jsr     I2CRREQ
   F8C6 96 03         [ 3]  144         ldaa    CMDBUF0
   F8C8 81 52         [ 2]  145         cmpa    #0x52           ; 'R' - Read memory
   F8CA 27 0A         [ 4]  146         beq     MREAD
   F8CC 81 57         [ 2]  147         cmpa    #0x57           ; 'W' - Write memory
   F8CE 27 10         [ 4]  148         beq     MWRITE
   F8D0 81 43         [ 2]  149         cmpa    #0x43           ; 'C' - Call subroutine
   F8D2 27 28         [ 4]  150         beq     REMCALL
   F8D4 0C            [ 2]  151         clc
   F8D5 39            [ 5]  152         rts
                            153 
   F8D6                     154 MREAD:
   F8D6 BD F8 EE      [ 9]  155         jsr     LOADBC
   F8D9 DE 01         [ 4]  156         ldx     BREG
   F8DB A6 00         [ 5]  157         ldaa    0,X
   F8DD 7E F8 F7      [ 3]  158         jmp     SRESP
   F8E0                     159 MWRITE:
   F8E0 BD F8 EE      [ 9]  160         jsr     LOADBC
   F8E3 96 06         [ 3]  161         ldaa    CMDBUF3
   F8E5 DE 01         [ 4]  162         ldx     BREG
   F8E7 A7 00         [ 6]  163         staa    0,X
   F8E9 86 57         [ 2]  164         ldaa    #0x57   ;'W'
   F8EB 7E F8 F7      [ 3]  165         jmp     SRESP
   F8EE                     166 LOADBC:
   F8EE 96 04         [ 3]  167         ldaa    CMDBUF1
   F8F0 97 01         [ 4]  168         staa    BREG
   F8F2 96 05         [ 3]  169         ldaa    CMDBUF2
   F8F4 97 02         [ 4]  170         staa    C
   F8F6 39            [ 5]  171         rts
                            172         
   F8F7                     173 SRESP:
   F8F7 BD F8 B2      [ 9]  174         jsr    I2CSRESP
   F8FA                     175 RHERE:
   F8FA 0D            [ 2]  176         sec
   F8FB 39            [ 5]  177         rts
   F8FC                     178 REMCALL:
   F8FC 86 F7         [ 2]  179         ldaa    #>(START-1)
   F8FE 36            [ 4]  180         psha
   F8FF 86 FF         [ 2]  181         ldaa    #<(START-1)
   F901 36            [ 4]  182         psha
   F902 BD F8 EE      [ 9]  183         jsr     LOADBC
   F905 DE 01         [ 4]  184         ldx     BREG
   F907 6E 00         [ 4]  185         jmp     0,X
                            186         
                            187 ;;;;;;;;;;
                             41 ;
                             42 ;       EVERY CODE
                             43 ;
   F909                      44 EVERY:
                             45 ;       YOUR CODE CAN GO HERE
   F909 39            [ 5]   46         rts
                             47 
                             48         .include "../io/6800_romio.asm"
   F90A 96 00         [ 3]    1 SETSCL: ldaa    OUTBUF
   F90C 8A 01         [ 2]    2         oraa    #0x01
   F90E 97 00         [ 4]    3         staa    OUTBUF
   F910 8B C0         [ 2]    4         adda    #<(IOREGW)
   F912 97 02         [ 4]    5         staa    C
   F914 86 FF         [ 2]    6         ldaa    #>(IOREGW)
   F916 97 01         [ 4]    7         staa    BREG
   F918 DE 01         [ 4]    8         ldx     BREG
   F91A A6 00         [ 5]    9         ldaa    0,X
   F91C BD F8 32      [ 9]   10         jsr     I2CDLY
   F91F 39            [ 5]   11         rts
                             12 
   F920 96 00         [ 3]   13 CLRSCL: ldaa    OUTBUF
   F922 84 1E         [ 2]   14         anda    #0x1e
   F924 97 00         [ 4]   15         staa    OUTBUF
   F926 8B C0         [ 2]   16         adda    #<(IOREGW) ;biffs carry flag!
   F928 97 02         [ 4]   17         staa    C
   F92A 86 FF         [ 2]   18         ldaa    #>(IOREGW)
   F92C 97 01         [ 4]   19         staa    BREG
   F92E DE 01         [ 4]   20         ldx     BREG
   F930 A6 00         [ 5]   21         ldaa    0,X
   F932 39            [ 5]   22         rts
                             23 
   F933 96 00         [ 3]   24 SETSDA: ldaa    OUTBUF
   F935 84 1D         [ 2]   25         anda    #0x1d
   F937 97 00         [ 4]   26         staa    OUTBUF
   F939 8B C0         [ 2]   27         adda    #<(IOREGW)
   F93B 97 02         [ 4]   28         staa    C
   F93D 86 FF         [ 2]   29         ldaa    #>(IOREGW)
   F93F 97 01         [ 4]   30         staa    BREG
   F941 DE 01         [ 4]   31         ldx     BREG
   F943 A6 00         [ 5]   32         ldaa    0,X
   F945 BD F8 32      [ 9]   33         jsr     I2CDLY
   F948 39            [ 5]   34         rts
                             35 
   F949 96 00         [ 3]   36 CLRSDA: ldaa    OUTBUF
   F94B 8A 02         [ 2]   37         oraa    #0x02
   F94D 97 00         [ 4]   38         staa    OUTBUF
   F94F 8B C0         [ 2]   39         adda    #<(IOREGW)
   F951 97 02         [ 4]   40         staa    C
   F953 86 FF         [ 2]   41         ldaa    #>(IOREGW)
   F955 97 01         [ 4]   42         staa    BREG
   F957 DE 01         [ 4]   43         ldx     BREG
   F959 A6 00         [ 5]   44         ldaa    0,X
   F95B BD F8 32      [ 9]   45         jsr     I2CDLY
   F95E 39            [ 5]   46         rts
                             47 
   F95F                      48 READSDA:
   F95F 96 00         [ 3]   49         ldaa    OUTBUF
   F961 8B A0         [ 2]   50         adda    #<(IOREGR)
   F963 97 02         [ 4]   51         staa    C
   F965 86 FF         [ 2]   52         ldaa    #>(IOREGR)
   F967 97 01         [ 4]   53         staa    BREG
   F969 DE 01         [ 4]   54         ldx     BREG
   F96B A6 00         [ 5]   55         ldaa    0,X
   F96D 46            [ 2]   56         rora
   F96E 39            [ 5]   57         rts
                             58                              
                             49 ;
                             50 ;       NMI HANDLER
                             51 ;
   F96F                      52 NMI:
   F96F 3B            [10]   53         rti
                             54 
                             55 
                             56 ;------- region2  -----------------------------------------------
                             57 
                             58         .bank   region2 (base=IOADD, size=IOEND-IOADD)
                             59         .area   region2 (ABS, BANK=region2)
                             60 
                             61         .include "../io/romio_table.asm"
                              1 
                              2 ; 
                              3 ; For Demon Debugger Hardware - Rev D 
                              4 ;
                              5 ; In earlier hardware designs, I tried to capture the address bus bits on a 
                              6 ; read cycle, to use to write to the Arduino.  But it turns out it is impossible
                              7 ; to know exactly when to sample these address bits across all platforms, designs, and 
                              8 ; clock speeds
                              9 ;
                             10 ; The solution I came up with was to make sure the data bus contains the same information
                             11 ; as the lower address bus during these read cycles, so that I can sample the data bus just like the 
                             12 ; CPU would.
                             13 ;
                             14 ; This block of memory, starting at 0x07c0, is filled with consecutive integers.
                             15 ; When the CPU reads from a location, the data bus matches the lower bits of the address bus.  
                             16 ; And the data bus read by the CPU is also written to the Arduino.
                             17 ; 
                             18 ; Note: Currently, only the bottom two bits are used, but reserving the memory
                             19 ; this way insures that up to 5 bits could be used 
                             20 ; 
                             21         ; ROMIO READ Area - reserved
   FFA0 FF FF FF FF FF FF    22         .DB     0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
        FF FF FF FF FF FF
        FF FF FF FF
   FFB0 FF FF FF FF FF FF    23         .DB     0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
        FF FF FF FF FF FF
        FF FF FF FF
                             24 
                             25         ; ROMIO WRITE Area - data is used
   FFC0 00 01 02 03 04 05    26         .DB     0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f
        06 07 08 09 0A 0B
        0C 0D 0E 0F
   FFD0 10 11 12 13 14 15    27         .DB     0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
        16 17 18 19 1A 1B
        1C 1D 1E 1F
                             28 
                             62 
                             63 ;------- region3  -----------------------------------------------
                             64 
                             65         .bank   region3 (base=VECTORS, size=ROMSIZE-VECTORS)
                             66         .area   region3 (ABS, BANK=region3)
                             67 
                             68         .include "../core/6800_vectors.asm"
   FFF8 F8 00                 1         .dw     START   ;IRQ
   FFFA F8 00                 2         .dw     START   ;SWI
   FFFC F9 6F                 3         .dw     NMI
   FFFE F8 00                 4         .dw     START
                             69 
