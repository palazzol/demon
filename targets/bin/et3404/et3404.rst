                              1 ;****************************************************************
                              2 ; This file is auto-generated by ddmake from et3404.toml
                              3 ; *** DO NOT EDIT ***
                              4 ;****************************************************************
                              5 
                              6 ; Start of chip memory mapping
                     F800     7 STRTADD = 0xf800
                              8 
                              9 ; 2K ROM
                     0800    10 ROMSIZE = 0x0800
                             11 
                             12 ; Start of ram, needs 7 bytes starting here
                             13 ; On the 6502, you can usually you can count on there being RAM in page 0
                     0000    14 RAMSTRT = 0x0000
                             15 
                             16 ; Start of stack, needs some memory below this address
                     00FF    17 SSTACK = 0x00ff
                             18 
                             19 ; delay factor
                     0180    20 BIGDEL = 0x0180
                             21 
                             22         .include "../core/dd.def"
                              1 
                     0000     2 ROMEND  .equ    STRTADD+ROMSIZE
                              3 
                              4 
                             23         .include "../core/6809.def"
                              1 ; Same for all 6809s
                     FFF0     2 VECTORS .equ    0xfff0      ; location of Vector table
                             24         .include "../io/romio.def"
                              1 ; For Demon Debugger Hardware - Rev D 
                              2 
                     FFA0     3 IOREGR   .equ   STRTADD+0x07a0    ;reserved region for IO READ
                     FFC0     4 IOREGW   .equ   STRTADD+0x07c0    ;reserved region for IO WRITE
                              5 
                     FFA0     6 IOADD    .equ   IOREGR            ;start of region
                     FFE0     7 IOEND    .equ   STRTADD+0x07e0    ;end of region
                             25 
                             26 ;------- region1  -----------------------------------------------
                             27 
                             28         .bank   region1 (base=STRTADD, size=IOADD-STRTADD)
                             29         .area   region1 (ABS, BANK=region1)
                             30 
                             31 ;
                             32 ;       START CODE
                             33 ;
   F800                      34 START:
   F800 1A 10         [ 3]   35         sei              ; Disable interrupts - we don't handle them
   F802 10 CE 00 FF   [ 4]   36         lds     #SSTACK  ; set up the stack
                             37 ;       YOUR CODE CAN GO HERE
   F806 7E F8 09      [ 4]   38         jmp     INIT
                             39 
                             40         .include "../core/6809_main.asm"
                              1 
                              2 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              3 ; RAM Variables 
                              4 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              5 
                     0000     6 OUTBUF  .equ    RAMSTRT         ;buffer for output states
                     0001     7 BREG    .equ    RAMSTRT+0x01    ;general purpose
                     0002     8 C       .equ    RAMSTRT+0x02    ;general purpose
                     0003     9 CMDBUF0 .equ    RAMSTRT+0x03    ;command buffer
                     0004    10 CMDBUF1 .equ    RAMSTRT+0x04    ;command buffer
                     0005    11 CMDBUF2 .equ    RAMSTRT+0x05    ;command buffer
                     0006    12 CMDBUF3 .equ    RAMSTRT+0x06    ;command buffer
                             13 
                             14 ; I2C ADDRESSING
                     0011    15 I2CRADR .equ    0x11        ; I2C read address  - I2C address 0x08
                     0010    16 I2CWADR .equ    0x10        ; I2C write address - I2C address 0x08
                             17 
   F809                      18 INIT:
   F809 86 00         [ 2]   19         ldaa    #0x00
   F80B B7 00 00      [ 5]   20         staa    OUTBUF
                             21 
                             22 ; Main routine
   F80E                      23 MAIN:
   F80E BD F9 35      [ 8]   24         jsr     EVERY
   F811 BD F8 E0      [ 8]   25         jsr     POLL
   F814 25 F8         [ 3]   26         bcs     MAIN
   F816 86 01         [ 2]   27         ldaa    #BIGDEL>>8
   F818 B7 00 01      [ 5]   28         staa    BREG
   F81B 86 80         [ 2]   29         ldaa    #BIGDEL%256
   F81D B7 00 02      [ 5]   30         staa    C
   F820                      31 MLOOP:
   F820 B6 00 02      [ 5]   32         ldaa    C
   F823 27 06         [ 3]   33         beq     DECBOTH
   F825 7A 00 02      [ 7]   34         dec     C
   F828 7E F8 20      [ 4]   35         jmp     MLOOP
   F82B                      36 DECBOTH:
   F82B B6 00 01      [ 5]   37         ldaa    BREG
   F82E 27 DE         [ 3]   38         beq     MAIN
   F830 7A 00 02      [ 7]   39         dec     C
   F833 7A 00 01      [ 7]   40         dec     BREG
   F836 7E F8 20      [ 4]   41         jmp     MLOOP
                             42 
                             43 ; Delay for half a bit time
   F839 39            [ 5]   44 I2CDLY: rts             ; TBD - this is plenty?
                             45 
                             46 ; I2C Start Condition
   F83A                      47 I2CSTART:
   F83A BD F9 84      [ 8]   48         jsr    CLRSDA      
   F83D BD F9 51      [ 8]   49         jsr    CLRSCL
   F840 39            [ 5]   50         rts
                             51 
                             52 ; I2C Stop Condition
                             53 ; Uses HL
                             54 ; Destroys A
   F841                      55 I2CSTOP:
   F841 BD F9 84      [ 8]   56         jsr    CLRSDA
   F844 BD F9 36      [ 8]   57         jsr    SETSCL
   F847 BD F9 69      [ 8]   58         jsr    SETSDA
   F84A 39            [ 5]   59         rts
                             60         
   F84B                      61 I2CRBIT:
   F84B BD F9 69      [ 8]   62         jsr     SETSDA
   F84E BD F9 36      [ 8]   63         jsr     SETSCL
   F851 BD F9 9F      [ 8]   64         jsr     READSDA ; sets/clears carry flag
   F854 49            [ 2]   65         rola            ; save carry flag here
   F855 34 02         [ 6]   66         psha
   F857 BD F9 51      [ 8]   67         jsr     CLRSCL
   F85A 35 02         [ 6]   68         pula
   F85C 46            [ 2]   69         rora            ; restore carry flag here
   F85D 39            [ 5]   70         rts             ; carry flag still good here
                             71 
   F85E                      72 I2CWBIT:
   F85E 24 06         [ 3]   73         bcc     DOCLR
   F860 BD F9 69      [ 8]   74         jsr     SETSDA
   F863 7E F8 69      [ 4]   75         jmp     AHEAD
   F866                      76 DOCLR:
   F866 BD F9 84      [ 8]   77         jsr     CLRSDA
   F869                      78 AHEAD:
   F869 BD F9 36      [ 8]   79         jsr     SETSCL
   F86C BD F9 51      [ 8]   80         jsr     CLRSCL
   F86F 39            [ 5]   81         rts
                             82         
   F870                      83 I2CWBYTE:
   F870 C6 08         [ 2]   84         ldab    #0x08   
   F872                      85 ILOOP:
   F872 49            [ 2]   86         rola                ; high bit into carry
   F873 34 02         [ 6]   87         psha
   F875 BD F8 5E      [ 8]   88         jsr     I2CWBIT
   F878 35 02         [ 6]   89         pula
   F87A 5A            [ 2]   90         decb
   F87B 26 F5         [ 3]   91         bne     ILOOP
   F87D BD F8 4B      [ 8]   92         jsr     I2CRBIT
   F880 39            [ 5]   93         rts
                             94         
   F881                      95 I2CRBYTE:
   F881 C6 08         [ 2]   96         ldab    #0x08
   F883 86 00         [ 2]   97         ldaa    #0x00
   F885                      98 LOOP3:
   F885 34 02         [ 6]   99         psha
   F887 BD F8 4B      [ 8]  100         jsr     I2CRBIT     ; get bit in carry flag
   F88A 35 02         [ 6]  101         pula
   F88C 49            [ 2]  102         rola                ; rotate carry into bit0
   F88D 5A            [ 2]  103         decb
   F88E 26 F5         [ 3]  104         bne     LOOP3
   F890 1C FE         [ 3]  105         clc                 ; clear carry flag 
   F892 34 02         [ 6]  106         psha             
   F894 BD F8 5E      [ 8]  107         jsr     I2CWBIT
   F897 35 02         [ 6]  108         pula
   F899 39            [ 5]  109         rts
                            110 
   F89A                     111 I2CRREQ:
   F89A BD F8 3A      [ 8]  112         jsr     I2CSTART
   F89D 86 11         [ 2]  113         ldaa    #I2CRADR
   F89F BD F8 70      [ 8]  114         jsr     I2CWBYTE
   F8A2 25 1E         [ 3]  115         bcs     SKIP
   F8A4 BD F8 81      [ 8]  116         jsr     I2CRBYTE
   F8A7 B7 00 03      [ 5]  117         staa    CMDBUF0
   F8AA BD F8 81      [ 8]  118         jsr     I2CRBYTE
   F8AD B7 00 04      [ 5]  119         staa    CMDBUF1
   F8B0 BD F8 81      [ 8]  120         jsr     I2CRBYTE
   F8B3 B7 00 05      [ 5]  121         staa    CMDBUF2
   F8B6 BD F8 81      [ 8]  122         jsr     I2CRBYTE
   F8B9 B7 00 06      [ 5]  123         staa    CMDBUF3
   F8BC BD F8 DC      [ 8]  124         jsr     ENDI2C
   F8BF 1C FE         [ 3]  125         clc                 ; everything was ok
   F8C1 39            [ 5]  126         rts
                            127     
   F8C2                     128 SKIP:                       ; If no device present, fake an idle response
   F8C2 86 2E         [ 2]  129         ldaa    #0x2e  ; '.'
   F8C4 B7 00 03      [ 5]  130         staa    CMDBUF0
   F8C7 BD F8 DC      [ 8]  131         jsr     ENDI2C
   F8CA 1A 01         [ 3]  132         sec                 ; aborted return
   F8CC 39            [ 5]  133         rts 
                            134 
   F8CD                     135 I2CSRESP:
   F8CD 34 02         [ 6]  136         psha
   F8CF BD F8 3A      [ 8]  137         jsr     I2CSTART
   F8D2 86 10         [ 2]  138         ldaa    #I2CWADR
   F8D4 BD F8 70      [ 8]  139         jsr     I2CWBYTE
   F8D7 35 02         [ 6]  140         pula
   F8D9 BD F8 70      [ 8]  141         jsr     I2CWBYTE
   F8DC                     142 ENDI2C:
   F8DC BD F8 41      [ 8]  143         jsr     I2CSTOP
   F8DF 39            [ 5]  144         rts
                            145 
   F8E0                     146 POLL:
   F8E0 BD F8 9A      [ 8]  147         jsr     I2CRREQ
   F8E3 25 0F         [ 3]  148         bcs     ABORT
   F8E5 B6 00 03      [ 5]  149         ldaa    CMDBUF0
   F8E8 81 52         [ 2]  150         cmpa    #0x52           ; 'R' - Read memory
   F8EA 27 0B         [ 3]  151         beq     MREAD
   F8EC 81 57         [ 2]  152         cmpa    #0x57           ; 'W' - Write memory
   F8EE 27 12         [ 3]  153         beq     MWRITE
   F8F0 81 43         [ 2]  154         cmpa    #0x43           ; 'C' - Call subroutine
   F8F2 27 31         [ 3]  155         beq     REMCALL
   F8F4                     156 ABORT:
   F8F4 1C FE         [ 3]  157         clc                     ; dont request again right away
   F8F6 39            [ 5]  158         rts
                            159 
   F8F7                     160 MREAD:
   F8F7 BD F9 12      [ 8]  161         jsr     LOADBC
   F8FA BE 00 01      [ 6]  162         ldx     BREG
   F8FD A6 00         [ 5]  163         ldaa    0,X
   F8FF 7E F9 1F      [ 4]  164         jmp     SRESP
   F902                     165 MWRITE:
   F902 BD F9 12      [ 8]  166         jsr     LOADBC
   F905 B6 00 06      [ 5]  167         ldaa    CMDBUF3
   F908 BE 00 01      [ 6]  168         ldx     BREG
   F90B A7 00         [ 5]  169         staa    0,X
   F90D 86 57         [ 2]  170         ldaa    #0x57   ;'W'
   F90F 7E F9 1F      [ 4]  171         jmp     SRESP
   F912                     172 LOADBC:
   F912 B6 00 04      [ 5]  173         ldaa    CMDBUF1
   F915 B7 00 01      [ 5]  174         staa    BREG
   F918 B6 00 05      [ 5]  175         ldaa    CMDBUF2
   F91B B7 00 02      [ 5]  176         staa    C
   F91E 39            [ 5]  177         rts
                            178         
   F91F                     179 SRESP:
   F91F BD F8 CD      [ 8]  180         jsr    I2CSRESP
   F922                     181 RHERE:
   F922 1A 01         [ 3]  182         sec                     ; request again right away
   F924 39            [ 5]  183         rts
   F925                     184 REMCALL:
   F925 86 F7         [ 2]  185         ldaa    #>(START-1)
   F927 34 02         [ 6]  186         psha
   F929 86 FF         [ 2]  187         ldaa    #<(START-1)
   F92B 34 02         [ 6]  188         psha
   F92D BD F9 12      [ 8]  189         jsr     LOADBC
   F930 BE 00 01      [ 6]  190         ldx     BREG
   F933 6E 00         [ 4]  191         jmp     0,X
                            192         
                            193 ;;;;;;;;;;
                             41 ;
                             42 ;       EVERY CODE
                             43 ;
   F935                      44 EVERY:
                             45 ;       YOUR CODE CAN GO HERE
   F935 39            [ 5]   46         rts
                             47 
                             48         .include "../io/6809_romio.asm"
   F936 B6 00 00      [ 5]    1 SETSCL: ldaa    OUTBUF
   F939 8A 01         [ 2]    2         oraa    #0x01
   F93B B7 00 00      [ 5]    3         staa    OUTBUF
   F93E 8B C0         [ 2]    4         adda    #<(IOREGW)
   F940 B7 00 02      [ 5]    5         staa    C
   F943 86 FF         [ 2]    6         ldaa    #>(IOREGW)
   F945 B7 00 01      [ 5]    7         staa    BREG
   F948 BE 00 01      [ 6]    8         ldx     BREG
   F94B A6 00         [ 5]    9         ldaa    0,X
   F94D BD F8 39      [ 8]   10         jsr     I2CDLY
   F950 39            [ 5]   11         rts
                             12 
   F951 B6 00 00      [ 5]   13 CLRSCL: ldaa    OUTBUF
   F954 84 1E         [ 2]   14         anda    #0x1e
   F956 B7 00 00      [ 5]   15         staa    OUTBUF
   F959 8B C0         [ 2]   16         adda    #<(IOREGW) ;biffs carry flag!
   F95B B7 00 02      [ 5]   17         staa    C
   F95E 86 FF         [ 2]   18         ldaa    #>(IOREGW)
   F960 B7 00 01      [ 5]   19         staa    BREG
   F963 BE 00 01      [ 6]   20         ldx     BREG
   F966 A6 00         [ 5]   21         ldaa    0,X
   F968 39            [ 5]   22         rts
                             23 
   F969 B6 00 00      [ 5]   24 SETSDA: ldaa    OUTBUF
   F96C 84 1D         [ 2]   25         anda    #0x1d
   F96E B7 00 00      [ 5]   26         staa    OUTBUF
   F971 8B C0         [ 2]   27         adda    #<(IOREGW)
   F973 B7 00 02      [ 5]   28         staa    C
   F976 86 FF         [ 2]   29         ldaa    #>(IOREGW)
   F978 B7 00 01      [ 5]   30         staa    BREG
   F97B BE 00 01      [ 6]   31         ldx     BREG
   F97E A6 00         [ 5]   32         ldaa    0,X
   F980 BD F8 39      [ 8]   33         jsr     I2CDLY
   F983 39            [ 5]   34         rts
                             35 
   F984 B6 00 00      [ 5]   36 CLRSDA: ldaa    OUTBUF
   F987 8A 02         [ 2]   37         oraa    #0x02
   F989 B7 00 00      [ 5]   38         staa    OUTBUF
   F98C 8B C0         [ 2]   39         adda    #<(IOREGW)
   F98E B7 00 02      [ 5]   40         staa    C
   F991 86 FF         [ 2]   41         ldaa    #>(IOREGW)
   F993 B7 00 01      [ 5]   42         staa    BREG
   F996 BE 00 01      [ 6]   43         ldx     BREG
   F999 A6 00         [ 5]   44         ldaa    0,X
   F99B BD F8 39      [ 8]   45         jsr     I2CDLY
   F99E 39            [ 5]   46         rts
                             47 
   F99F                      48 READSDA:
   F99F B6 00 00      [ 5]   49         ldaa    OUTBUF
   F9A2 8B A0         [ 2]   50         adda    #<(IOREGR)
   F9A4 B7 00 02      [ 5]   51         staa    C
   F9A7 86 FF         [ 2]   52         ldaa    #>(IOREGR)
   F9A9 B7 00 01      [ 5]   53         staa    BREG
   F9AC BE 00 01      [ 6]   54         ldx     BREG
   F9AF A6 00         [ 5]   55         ldaa    0,X
   F9B1 46            [ 2]   56         rora
   F9B2 39            [ 5]   57         rts
                             58                              
                             49 ;
                             50 ;       NMI HANDLER
                             51 ;
   F9B3                      52 NMI:
   F9B3 3B            [15]   53         rti
                             54 
                             55 
                             56 ;------- region2  -----------------------------------------------
                             57 
                             58         .bank   region2 (base=IOADD, size=IOEND-IOADD)
                             59         .area   region2 (ABS, BANK=region2)
                             60 
                             61         .include "../io/romio_table.asm"
                              1 
                              2 ; 
                              3 ; For Demon Debugger Hardware - Rev D 
                              4 ;
                              5 ; In earlier hardware designs, I tried to capture the address bus bits on a 
                              6 ; read cycle, to use to write to the Arduino.  But it turns out it is impossible
                              7 ; to know exactly when to sample these address bits across all platforms, designs, and 
                              8 ; clock speeds
                              9 ;
                             10 ; The solution I came up with was to make sure the data bus contains the same information
                             11 ; as the lower address bus during these read cycles, so that I can sample the data bus just like the 
                             12 ; CPU would.
                             13 ;
                             14 ; This block of memory, starting at 0x07c0, is filled with consecutive integers.
                             15 ; When the CPU reads from a location, the data bus matches the lower bits of the address bus.  
                             16 ; And the data bus read by the CPU is also written to the Arduino.
                             17 ; 
                             18 ; Note: Currently, only the bottom two bits are used, but reserving the memory
                             19 ; this way insures that up to 5 bits could be used 
                             20 ; 
                             21         ; ROMIO READ Area - reserved
   FFA0 FF FF FF FF FF FF    22         .DB     0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
        FF FF FF FF FF FF
        FF FF FF FF
   FFB0 FF FF FF FF FF FF    23         .DB     0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
        FF FF FF FF FF FF
        FF FF FF FF
                             24 
                             25         ; ROMIO WRITE Area - data is used
   FFC0 00 01 02 03 04 05    26         .DB     0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f
        06 07 08 09 0A 0B
        0C 0D 0E 0F
   FFD0 10 11 12 13 14 15    27         .DB     0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
        16 17 18 19 1A 1B
        1C 1D 1E 1F
                             28 
                             62 
                             63 ;------- region3  -----------------------------------------------
                             64 
                             65         .bank   region3 (base=VECTORS, size=ROMSIZE-VECTORS)
                             66         .area   region3 (ABS, BANK=region3)
                             67 
                             68         .include "../core/6809_vectors.asm"
   FFF0 FF FF                 1         .dw     0xFFFF   ;RESERVED
   FFF2 F8 00                 2         .dw     START   ;SWI3
   FFF4 F8 00                 3         .dw     START   ;SWI2
   FFF6 F8 00                 4         .dw     START   ;FIRQ
   FFF8 F8 00                 5         .dw     START   ;IRQ
   FFFA F8 00                 6         .dw     START   ;SWI
   FFFC F9 B3                 7         .dw     NMI
   FFFE F8 00                 8         .dw     START
                             69 
