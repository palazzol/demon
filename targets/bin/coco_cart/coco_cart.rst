                              1 ;****************************************************************
                              2 ; This file is auto-generated by ddmake from coco_cart.toml
                              3 ; *** DO NOT EDIT ***
                              4 ;****************************************************************
                              5 
                              6 ; Start of chip memory mapping
                     C000     7 STRTADD = 0xc000
                              8 
                              9 ; 2K ROM
                     0800    10 ROMSIZE = 0x0800
                             11 
                             12 ; Start of ram, needs 7 bytes starting here
                             13 ; On the 6502, you can usually you can count on there being RAM in page 0
                     0000    14 RAMSTRT = 0x0000
                             15 
                             16 ; Start of stack, needs some memory below this address
                     00FF    17 SSTACK = 0x00ff
                             18 
                             19 ; delay factor
                     0180    20 BIGDEL = 0x0180
                             21 
                             22         .include "../core/dd.def"
                              1 
                     C800     2 ROMEND  .equ    STRTADD+ROMSIZE
                              3 
                              4 
                             23         .include "../core/6809.def"
                              1 ; Same for all 6809s
                     FFF0     2 VECTORS .equ    0xfff0      ; location of Vector table
                             24         .include "../io/romio.def"
                              1 ; For Demon Debugger Hardware - Rev D 
                              2 
                     C7A0     3 IOREGR   .equ   STRTADD+0x07a0    ;reserved region for IO READ
                     C7C0     4 IOREGW   .equ   STRTADD+0x07c0    ;reserved region for IO WRITE
                              5 
                     C7A0     6 IOADD    .equ   IOREGR            ;start of region
                     C7E0     7 IOEND    .equ   STRTADD+0x07e0    ;end of region
                             25 
                             26 ;------- region1  -----------------------------------------------
                             27 
                             28         .bank   region1 (base=STRTADD, size=IOADD-STRTADD)
                             29         .area   region1 (ABS, BANK=region1)
                             30 
                             31 ;
                             32 ;       START CODE
                             33 ;
   C000                      34 START:
   C000 1A 10         [ 3]   35         sei              ; Disable interrupts - we don't handle them
   C002 10 CE 00 FF   [ 4]   36         lds     #SSTACK  ; set up the stack
                             37 ;       YOUR CODE CAN GO HERE
   C006 7E C0 09      [ 4]   38         jmp     INIT
                             39 
                             40         .include "../core/6809_main.asm"
                              1 
                              2 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              3 ; RAM Variables 
                              4 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              5 
                     0000     6 OUTBUF  .equ    RAMSTRT         ;buffer for output states
                     0001     7 BREG    .equ    RAMSTRT+0x01    ;general purpose
                     0002     8 C       .equ    RAMSTRT+0x02    ;general purpose
                     0003     9 CMDBUF0 .equ    RAMSTRT+0x03    ;command buffer
                     0004    10 CMDBUF1 .equ    RAMSTRT+0x04    ;command buffer
                     0005    11 CMDBUF2 .equ    RAMSTRT+0x05    ;command buffer
                     0006    12 CMDBUF3 .equ    RAMSTRT+0x06    ;command buffer
                             13 
                             14 ; I2C ADDRESSING
                     0011    15 I2CRADR .equ    0x11        ; I2C read address  - I2C address 0x08
                     0010    16 I2CWADR .equ    0x10        ; I2C write address - I2C address 0x08
                             17 
   C009                      18 INIT:
   C009 86 00         [ 2]   19         ldaa    #0x00
   C00B B7 00 00      [ 5]   20         staa    OUTBUF
                             21 
                             22 ; Main routine
   C00E                      23 MAIN:
   C00E BD C1 35      [ 8]   24         jsr     EVERY
   C011 BD C0 E0      [ 8]   25         jsr     POLL
   C014 25 F8         [ 3]   26         bcs     MAIN
   C016 86 01         [ 2]   27         ldaa    #BIGDEL>>8
   C018 B7 00 01      [ 5]   28         staa    BREG
   C01B 86 80         [ 2]   29         ldaa    #BIGDEL%256
   C01D B7 00 02      [ 5]   30         staa    C
   C020                      31 MLOOP:
   C020 B6 00 02      [ 5]   32         ldaa    C
   C023 27 06         [ 3]   33         beq     DECBOTH
   C025 7A 00 02      [ 7]   34         dec     C
   C028 7E C0 20      [ 4]   35         jmp     MLOOP
   C02B                      36 DECBOTH:
   C02B B6 00 01      [ 5]   37         ldaa    BREG
   C02E 27 DE         [ 3]   38         beq     MAIN
   C030 7A 00 02      [ 7]   39         dec     C
   C033 7A 00 01      [ 7]   40         dec     BREG
   C036 7E C0 20      [ 4]   41         jmp     MLOOP
                             42 
                             43 ; Delay for half a bit time
   C039 39            [ 5]   44 I2CDLY: rts             ; TBD - this is plenty?
                             45 
                             46 ; I2C Start Condition
   C03A                      47 I2CSTART:
   C03A BD C1 84      [ 8]   48         jsr    CLRSDA      
   C03D BD C1 51      [ 8]   49         jsr    CLRSCL
   C040 39            [ 5]   50         rts
                             51 
                             52 ; I2C Stop Condition
                             53 ; Uses HL
                             54 ; Destroys A
   C041                      55 I2CSTOP:
   C041 BD C1 84      [ 8]   56         jsr    CLRSDA
   C044 BD C1 36      [ 8]   57         jsr    SETSCL
   C047 BD C1 69      [ 8]   58         jsr    SETSDA
   C04A 39            [ 5]   59         rts
                             60         
   C04B                      61 I2CRBIT:
   C04B BD C1 69      [ 8]   62         jsr     SETSDA
   C04E BD C1 36      [ 8]   63         jsr     SETSCL
   C051 BD C1 9F      [ 8]   64         jsr     READSDA ; sets/clears carry flag
   C054 49            [ 2]   65         rola            ; save carry flag here
   C055 34 02         [ 6]   66         psha
   C057 BD C1 51      [ 8]   67         jsr     CLRSCL
   C05A 35 02         [ 6]   68         pula
   C05C 46            [ 2]   69         rora            ; restore carry flag here
   C05D 39            [ 5]   70         rts             ; carry flag still good here
                             71 
   C05E                      72 I2CWBIT:
   C05E 24 06         [ 3]   73         bcc     DOCLR
   C060 BD C1 69      [ 8]   74         jsr     SETSDA
   C063 7E C0 69      [ 4]   75         jmp     AHEAD
   C066                      76 DOCLR:
   C066 BD C1 84      [ 8]   77         jsr     CLRSDA
   C069                      78 AHEAD:
   C069 BD C1 36      [ 8]   79         jsr     SETSCL
   C06C BD C1 51      [ 8]   80         jsr     CLRSCL
   C06F 39            [ 5]   81         rts
                             82         
   C070                      83 I2CWBYTE:
   C070 C6 08         [ 2]   84         ldab    #0x08   
   C072                      85 ILOOP:
   C072 49            [ 2]   86         rola                ; high bit into carry
   C073 34 02         [ 6]   87         psha
   C075 BD C0 5E      [ 8]   88         jsr     I2CWBIT
   C078 35 02         [ 6]   89         pula
   C07A 5A            [ 2]   90         decb
   C07B 26 F5         [ 3]   91         bne     ILOOP
   C07D BD C0 4B      [ 8]   92         jsr     I2CRBIT
   C080 39            [ 5]   93         rts
                             94         
   C081                      95 I2CRBYTE:
   C081 C6 08         [ 2]   96         ldab    #0x08
   C083 86 00         [ 2]   97         ldaa    #0x00
   C085                      98 LOOP3:
   C085 34 02         [ 6]   99         psha
   C087 BD C0 4B      [ 8]  100         jsr     I2CRBIT     ; get bit in carry flag
   C08A 35 02         [ 6]  101         pula
   C08C 49            [ 2]  102         rola                ; rotate carry into bit0
   C08D 5A            [ 2]  103         decb
   C08E 26 F5         [ 3]  104         bne     LOOP3
   C090 1C FE         [ 3]  105         clc                 ; clear carry flag 
   C092 34 02         [ 6]  106         psha             
   C094 BD C0 5E      [ 8]  107         jsr     I2CWBIT
   C097 35 02         [ 6]  108         pula
   C099 39            [ 5]  109         rts
                            110 
   C09A                     111 I2CRREQ:
   C09A BD C0 3A      [ 8]  112         jsr     I2CSTART
   C09D 86 11         [ 2]  113         ldaa    #I2CRADR
   C09F BD C0 70      [ 8]  114         jsr     I2CWBYTE
   C0A2 25 1E         [ 3]  115         bcs     SKIP
   C0A4 BD C0 81      [ 8]  116         jsr     I2CRBYTE
   C0A7 B7 00 03      [ 5]  117         staa    CMDBUF0
   C0AA BD C0 81      [ 8]  118         jsr     I2CRBYTE
   C0AD B7 00 04      [ 5]  119         staa    CMDBUF1
   C0B0 BD C0 81      [ 8]  120         jsr     I2CRBYTE
   C0B3 B7 00 05      [ 5]  121         staa    CMDBUF2
   C0B6 BD C0 81      [ 8]  122         jsr     I2CRBYTE
   C0B9 B7 00 06      [ 5]  123         staa    CMDBUF3
   C0BC BD C0 DC      [ 8]  124         jsr     ENDI2C
   C0BF 1C FE         [ 3]  125         clc                 ; everything was ok
   C0C1 39            [ 5]  126         rts
                            127     
   C0C2                     128 SKIP:                       ; If no device present, fake an idle response
   C0C2 86 2E         [ 2]  129         ldaa    #0x2e  ; '.'
   C0C4 B7 00 03      [ 5]  130         staa    CMDBUF0
   C0C7 BD C0 DC      [ 8]  131         jsr     ENDI2C
   C0CA 1A 01         [ 3]  132         sec                 ; aborted return
   C0CC 39            [ 5]  133         rts 
                            134 
   C0CD                     135 I2CSRESP:
   C0CD 34 02         [ 6]  136         psha
   C0CF BD C0 3A      [ 8]  137         jsr     I2CSTART
   C0D2 86 10         [ 2]  138         ldaa    #I2CWADR
   C0D4 BD C0 70      [ 8]  139         jsr     I2CWBYTE
   C0D7 35 02         [ 6]  140         pula
   C0D9 BD C0 70      [ 8]  141         jsr     I2CWBYTE
   C0DC                     142 ENDI2C:
   C0DC BD C0 41      [ 8]  143         jsr     I2CSTOP
   C0DF 39            [ 5]  144         rts
                            145 
   C0E0                     146 POLL:
   C0E0 BD C0 9A      [ 8]  147         jsr     I2CRREQ
   C0E3 25 0F         [ 3]  148         bcs     ABORT
   C0E5 B6 00 03      [ 5]  149         ldaa    CMDBUF0
   C0E8 81 52         [ 2]  150         cmpa    #0x52           ; 'R' - Read memory
   C0EA 27 0B         [ 3]  151         beq     MREAD
   C0EC 81 57         [ 2]  152         cmpa    #0x57           ; 'W' - Write memory
   C0EE 27 12         [ 3]  153         beq     MWRITE
   C0F0 81 43         [ 2]  154         cmpa    #0x43           ; 'C' - Call subroutine
   C0F2 27 31         [ 3]  155         beq     REMCALL
   C0F4                     156 ABORT:
   C0F4 1C FE         [ 3]  157         clc                     ; dont request again right away
   C0F6 39            [ 5]  158         rts
                            159 
   C0F7                     160 MREAD:
   C0F7 BD C1 12      [ 8]  161         jsr     LOADBC
   C0FA BE 00 01      [ 6]  162         ldx     BREG
   C0FD A6 00         [ 5]  163         ldaa    0,X
   C0FF 7E C1 1F      [ 4]  164         jmp     SRESP
   C102                     165 MWRITE:
   C102 BD C1 12      [ 8]  166         jsr     LOADBC
   C105 B6 00 06      [ 5]  167         ldaa    CMDBUF3
   C108 BE 00 01      [ 6]  168         ldx     BREG
   C10B A7 00         [ 5]  169         staa    0,X
   C10D 86 57         [ 2]  170         ldaa    #0x57   ;'W'
   C10F 7E C1 1F      [ 4]  171         jmp     SRESP
   C112                     172 LOADBC:
   C112 B6 00 04      [ 5]  173         ldaa    CMDBUF1
   C115 B7 00 01      [ 5]  174         staa    BREG
   C118 B6 00 05      [ 5]  175         ldaa    CMDBUF2
   C11B B7 00 02      [ 5]  176         staa    C
   C11E 39            [ 5]  177         rts
                            178         
   C11F                     179 SRESP:
   C11F BD C0 CD      [ 8]  180         jsr    I2CSRESP
   C122                     181 RHERE:
   C122 1A 01         [ 3]  182         sec                     ; request again right away
   C124 39            [ 5]  183         rts
   C125                     184 REMCALL:
   C125 86 BF         [ 2]  185         ldaa    #>(START-1)
   C127 34 02         [ 6]  186         psha
   C129 86 FF         [ 2]  187         ldaa    #<(START-1)
   C12B 34 02         [ 6]  188         psha
   C12D BD C1 12      [ 8]  189         jsr     LOADBC
   C130 BE 00 01      [ 6]  190         ldx     BREG
   C133 6E 00         [ 4]  191         jmp     0,X
                            192         
                            193 ;;;;;;;;;;
                             41 ;
                             42 ;       EVERY CODE
                             43 ;
   C135                      44 EVERY:
                             45 ;       YOUR CODE CAN GO HERE
   C135 39            [ 5]   46         rts
                             47 
                             48         .include "../io/6809_romio.asm"
   C136 B6 00 00      [ 5]    1 SETSCL: ldaa    OUTBUF
   C139 8A 01         [ 2]    2         oraa    #0x01
   C13B B7 00 00      [ 5]    3         staa    OUTBUF
   C13E 8B C0         [ 2]    4         adda    #<(IOREGW)
   C140 B7 00 02      [ 5]    5         staa    C
   C143 86 C7         [ 2]    6         ldaa    #>(IOREGW)
   C145 B7 00 01      [ 5]    7         staa    BREG
   C148 BE 00 01      [ 6]    8         ldx     BREG
   C14B A6 00         [ 5]    9         ldaa    0,X
   C14D BD C0 39      [ 8]   10         jsr     I2CDLY
   C150 39            [ 5]   11         rts
                             12 
   C151 B6 00 00      [ 5]   13 CLRSCL: ldaa    OUTBUF
   C154 84 1E         [ 2]   14         anda    #0x1e
   C156 B7 00 00      [ 5]   15         staa    OUTBUF
   C159 8B C0         [ 2]   16         adda    #<(IOREGW) ;biffs carry flag!
   C15B B7 00 02      [ 5]   17         staa    C
   C15E 86 C7         [ 2]   18         ldaa    #>(IOREGW)
   C160 B7 00 01      [ 5]   19         staa    BREG
   C163 BE 00 01      [ 6]   20         ldx     BREG
   C166 A6 00         [ 5]   21         ldaa    0,X
   C168 39            [ 5]   22         rts
                             23 
   C169 B6 00 00      [ 5]   24 SETSDA: ldaa    OUTBUF
   C16C 84 1D         [ 2]   25         anda    #0x1d
   C16E B7 00 00      [ 5]   26         staa    OUTBUF
   C171 8B C0         [ 2]   27         adda    #<(IOREGW)
   C173 B7 00 02      [ 5]   28         staa    C
   C176 86 C7         [ 2]   29         ldaa    #>(IOREGW)
   C178 B7 00 01      [ 5]   30         staa    BREG
   C17B BE 00 01      [ 6]   31         ldx     BREG
   C17E A6 00         [ 5]   32         ldaa    0,X
   C180 BD C0 39      [ 8]   33         jsr     I2CDLY
   C183 39            [ 5]   34         rts
                             35 
   C184 B6 00 00      [ 5]   36 CLRSDA: ldaa    OUTBUF
   C187 8A 02         [ 2]   37         oraa    #0x02
   C189 B7 00 00      [ 5]   38         staa    OUTBUF
   C18C 8B C0         [ 2]   39         adda    #<(IOREGW)
   C18E B7 00 02      [ 5]   40         staa    C
   C191 86 C7         [ 2]   41         ldaa    #>(IOREGW)
   C193 B7 00 01      [ 5]   42         staa    BREG
   C196 BE 00 01      [ 6]   43         ldx     BREG
   C199 A6 00         [ 5]   44         ldaa    0,X
   C19B BD C0 39      [ 8]   45         jsr     I2CDLY
   C19E 39            [ 5]   46         rts
                             47 
   C19F                      48 READSDA:
   C19F B6 00 00      [ 5]   49         ldaa    OUTBUF
   C1A2 8B A0         [ 2]   50         adda    #<(IOREGR)
   C1A4 B7 00 02      [ 5]   51         staa    C
   C1A7 86 C7         [ 2]   52         ldaa    #>(IOREGR)
   C1A9 B7 00 01      [ 5]   53         staa    BREG
   C1AC BE 00 01      [ 6]   54         ldx     BREG
   C1AF A6 00         [ 5]   55         ldaa    0,X
   C1B1 46            [ 2]   56         rora
   C1B2 39            [ 5]   57         rts
                             58                              
                             49 
                             50 ;------- region2  -----------------------------------------------
                             51 
                             52         .bank   region2 (base=IOADD, size=IOEND-IOADD)
                             53         .area   region2 (ABS, BANK=region2)
                             54 
                             55         .include "../io/romio_table.asm"
                              1 
                              2 ; 
                              3 ; For Demon Debugger Hardware - Rev D 
                              4 ;
                              5 ; In earlier hardware designs, I tried to capture the address bus bits on a 
                              6 ; read cycle, to use to write to the Arduino.  But it turns out it is impossible
                              7 ; to know exactly when to sample these address bits across all platforms, designs, and 
                              8 ; clock speeds
                              9 ;
                             10 ; The solution I came up with was to make sure the data bus contains the same information
                             11 ; as the lower address bus during these read cycles, so that I can sample the data bus just like the 
                             12 ; CPU would.
                             13 ;
                             14 ; This block of memory, starting at 0x07c0, is filled with consecutive integers.
                             15 ; When the CPU reads from a location, the data bus matches the lower bits of the address bus.  
                             16 ; And the data bus read by the CPU is also written to the Arduino.
                             17 ; 
                             18 ; Note: Currently, only the bottom two bits are used, but reserving the memory
                             19 ; this way insures that up to 5 bits could be used 
                             20 ; 
                             21         ; ROMIO READ Area - reserved
   C7A0 FF FF FF FF FF FF    22         .DB     0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
        FF FF FF FF FF FF
        FF FF FF FF
   C7B0 FF FF FF FF FF FF    23         .DB     0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
        FF FF FF FF FF FF
        FF FF FF FF
                             24 
                             25         ; ROMIO WRITE Area - data is used
   C7C0 00 01 02 03 04 05    26         .DB     0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f
        06 07 08 09 0A 0B
        0C 0D 0E 0F
   C7D0 10 11 12 13 14 15    27         .DB     0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f
        16 17 18 19 1A 1B
        1C 1D 1E 1F
                             28 
                             56 
                             57 ;------- region3  -----------------------------------------------
                             58 
                             59         .bank   region3 (base=IOEND, size=ROMSIZE-IOEND)
                             60         .area   region3 (ABS, BANK=region3)
                             61 
                             62 
